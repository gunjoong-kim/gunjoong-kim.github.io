---
layout: post
author: Gunjoong Kim
---
# [C++ Study] 4.3 복사생성자와 소멸자
이 포스트는 이재범님의 씹어먹는 c++을 공부하는 과정에서 작성하였습니다. 공부한 것들을 정리하는 포스트입니다. 조금 더 자세한 내용을 원하시면 아래의 링크로 접속해주세요.

https://modoocode.com/188

## 소멸자
```css
Car::Car(const char* car_name){
    name=new char[strlen(car_name)+1];
}
```

우리는 동적할당을 통해 할당받은 메모리를 명시적으로 해제해주어야 한다고 알고 있습니다. c++에서는 delete가 그 행위를 하는데 위와 같이 자동차 클래스의 생성자가 자동차의 이름을 넣어주는 과정에서 메모리를 동적할당 받고 있습니다. 그렇다면 위에서 할당받은 메모리는 어디에서 해제되는 것일까요? 

위와 같은 기능을 지원하기 위해 c++에서는 소멸자(destructor)라는 기능을 지원합니다. 소멸자는 생성자와 마찬가지로 객체가 소멸할 때 자동으로 호출되는 함수입니다.

```css
Car::~Car(){
    if(name!=NULL){
        delete[] name;
    }
}
```

위와 같이 자동차객체의 이름이 존재할 경우 해당 메모리를 해제하는 것처럼 소멸자에 어떤 행위를 할 지 명시적으로 지정해줍니다. 소멸자는 객체의 이름 앞에 ~를 붙여주면 됩니다. 또한 소멸자는 어떠한 인수도 가지지 않으며 따라서 오버로딩 또한 가능하지 않습니다. 디폴트 생성자가 있었던 것 처럼 디폴트 소멸자 또한 존재합니다만 이 소멸자는 객체에 대한 아무런 작업도 수행하지 않습니다.

## 복사생성자
객체를 만드는 방법을 생각해 보았을 때 여러분은 어떤 것들이 생각나시나요?

일일히 생성자를 통해 객체를 생성할 수 도 있겠지만 이미 만들어 두었던 객체를 그대로 복사 붙여넣기 하는 방법도 있을 것입니다.

```css
class Car{
    char* name;
    int fuel;
    int max_velocity;

public:
    Car();
    Car(const Car& c){
        fuel=c.fuel;
        max_velocity=c.max_velocity;
        name=c.name;
    }
};
```
위 코드를 보았을때 자동차 레퍼런스타입 c를 인수로 받는 생성자가 복사생성자의 표준적인 정의를 담고 있습니다.

넘겨받은 레퍼런스타입 c의 값들을 새롭게 생성되는 객체에 복사할 수 있다는 의미입니다. 이제 복사생성자가 어떻게 사용되는지 살펴봅시다.

```css
Car new_car(old_car);
Car new_car=old_car;
```
위 두 방식 모두 복사생성자를 사용하는 방식입니다. 특히 두번째 방식의 경우 일반적으로 대입연산으로 볼 수 있겠지만 컴파일러가 첫번째 방식으로 해석해 복사생성자를 호출합니다.

사실 c++에서는 디폴트 복사생성자가 존재하는데 위 코드에서 복사생성자를 정의한 부분을 지우고 실행시켜도 정확히 동일한 결과를 얻을 수 있습니다. 따라서 추가적인 처리가 필요하지 않는 경우 따로 복사생성자를 정의해주지 않아도 됩니다.

그렇다면 따로 복사생성자를 생성해주어야 하는 경우는 언제일까요?

사실 우리가 정의한
```css
Car(const Car& c){
    fuel=c.fuel;
    max_velocity=c.max_velocity;
    name=c.name;
}
```
이 복사생성자는 문제점을 하나 가지고 있습니다. 위 복사생성자를 통해 생성된 객체와 사용된 객체는 정확히 똑같은 값을 가지게 됩니다. 여기서 문제가 되는 부분은 바로 name 부분인데요 name은 위 클래스에서 char형 포인터로 정의되어 있습니다. 즉 두 객체가 가리키고 있는 주소값이 동일하다는 의미입니다. 사실 이 상태에서는 그렇게 큰 문제가 있지 않지만 만약 소멸자를 통해 한 객체를 먼저 소멸시키고 그 후에 다른 객체를 소멸시키는 상황에서 문제가 발생하는데 이미 소멸된 메모리공간에 대해 다시 delete를 적용할 수 없기때문입니다. 따라서 위 상황을 그대로 실행시키면 런타임오류를 뿜게 될 것입니다. 따라서 위와 같은 상황이 벌어지는 경우에서는 디폴트 복사생성자를 사용할 수 없습니다.

그러면 어떻게 이 문제를 해결할 수 있을까요? 

바로 name 포인터를 그대로 복사하지 않고 동적할당을 통해 새로 메모리를 할당받은 후에 내용만 복사하는 것입니다. 이와 같이 메모리를 새로 할당하여 복사하는 것을 깊은복사(Deep Copy)라고 하고 아까와 같이 단순히 대입만 해주는 것을 얕은복사(Shallow Copy)라고 부릅니다. 따라서 깊은복사가 필요한 경우 따로 복사생성자를 지정해주어야 합니다.
```css
Car(const Car& c){
    fuel=c.fuel;
    max_velocity=c.max_velocity;
    name=new char[strlen(c.name)+1];
    strcpy(name,c.name);
}
```
위와 같이 새로 메모리를 할당하고 strcpy합수를 통해 문자열의 내용을 복사시켜줌으로서 문제를 해결할 수 있습니다.

추가로 객체에 어떤 객체를 넘길 때 여러 타입의 복사가 사용될 수 있습니다. 그냥 객체를 따로 넘길 경우 위 객체는 깊은복사되어 넘어가게 됩니다. 반면 포인터나 레퍼런스타입의 객체가 넘어갈 경우에는 해당 포인터를 넘기므로 얕은복사된다고 볼 수 있습니다. 즉 객체를 넘긴 경우에 원래 객체와 넘어간 객체는 다른 객체입니다. 따라서 함수내에서 넘어간 객체를 조작한 경우에 원래 객체에 영향을 끼치지 못합니다. 반면 포인터나 레퍼런스타입의 객체를 넘긴 경우 넘어간 객체를 조작함으로서 원래 객체 또한 조작할 수 있습니다.






